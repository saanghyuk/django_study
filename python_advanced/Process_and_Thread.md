### Process and Thread

- OS가 도는데 그 위에서 프로그램을 실행시키려고 하면, 원래는 프로그램을 짤때는, 실제로는 CPU, Memory부터 온갖 하드웨어를 다 어떻게 제어할지를 프로그래머가 다 결정했어야 함. 컴퓨터에는 하드웨어가 엄청 많고, 그걸 다 컨트롤 하는 건 너무 어려워*(1+2만 하려고 해도 심지어 하드웨어마다 스펙도 다 다름)*. 그걸 하나 하나 다 하는게 너무 말이 안되니깐, "너네는 이렇게만 하면 돼!" 라고 하면, 그걸 추상화라고 함. 맨 밑에는 기계 하나에 0101, 1010 넣을지 정해서 추상화 해 놓은 사람이 있고, 그 위에 0101을 assembly이런거로 바꿔서 추상화 해 놓은 사람이 있고, 그 위에 C가 있고 그 위에 파이썬이 있고 각 단계마다 하나씩 다 추상화되어 있는 것. 파이썬은 거의 맨 꼭대기 엄청 높은 추상화 단계.
  - 예를 들어 내가 print()를 치면, 콘솔에 출력되게 한 것도 누군가 추상화 해놓은 수 많은 단계를 거쳐서 가능한 것. print()하나 찍는것도 내 코드로부터 컴퓨터의 0101까지 가는데 수 많은 단계를 거쳐 간 것.
  - 추상화 한줄요약 : **내가 그 앞 단계의 복잡한 단계를 고민 안해도 되게 만들어 놓은 것.**
- 메모리 관리는 OS가 해주게 되는데, 운영체제 위에는 프로그램이 엄청 돌고 있음. 예전에는, 프로그래머들한테 "너네가 프로그램 짜면서 어떤 정보를 메모리에 어디다가 어떻게 무엇을 저장할지 다 정해" 라고 했었음. 예컨데, 한글 프로그램 짜는 사람은 1~5번 메모리에 저장하겠다고 해놓고, 크롬 개발자는 10~15번까지 저장하겠다고 정했었음. 근데 이러다가, 내가 넣으려니깐 다른 프로그램 짠 사람이 1~5번에 넣어 놓게 해서 이미 거기에 다른게 들어있으면 어떻게 해? 내가 애초에 코드를 짜면서 남이 어디다가 뭘 어떻게 넣을지 어떻게 알고 생각하고 코드를 만들수가 있음? 그래서 OS 에서 "이런거를 너네 프로그래머들한테 안맡기고 알아서 해줄게. 너네는 그냥 메모리가 얼마 있다고 치고 프로그램 짜면 내가 알아서 적당한 곳에 잘 넣어줄게."라고 된 것. 실제로 프로그램 돌 때도 보면, 크롬쓰는 메모리가 막 여기저기 흩어져서 가있고, 엑셀이 쓰는 메모리도 막 여기저기 가있으면서 실행됨. 프로그래머는 따로 그런 생각을 안하면서 짤 수 있는 것 또한 추상화의 결과.
- OS가 이런 추상화를 하게 해 준 것. '_너네 프로그램 짜면서, CPU의 얼만큼, 메모리의 얼만큼을 짤 수 있다고 생각하고 짜라_' 미리 약속되어 있음. 우리가 프로그램을 돌리면, 그때부터는 OS가 알아서 메모리 관리 하면서 이거 실행시켰다가 저거 실행시켰다가 하면서 돌아(우리 눈에는 유튜브와 엑셀이 같이 실행되는거로 보이지만 실제로 깊이 가보면, 빠르게 돌아가면서 실행시키고 있음).
- 프로그램은 내가 짠 코드를 일컫음. 내가 짠 코드가 OS위에서 돌아가는 순간 그 **살아있는 코드를 프로세스**라고 함. 실행시키고 있으면 프로세스, 죽어있는 상태면 프로그램이라고 부름. 그 OS위에서 돌아가는 프로세스 상태에서의 가정과 규약(이 프로그램을 어떤 기계에서 돌리는지, 저장할 공간은 어딘지, 메모리에 어떻게 저장될지)이 그 OS dependent 하게 이루어 지고 있는 것. 즉, 프로그래머가 굳이 그런 것 까지 신경쓰지 않아도 되는 이유는, OS가 미리 추상화 해 놓은 상태이기 때문(한 OS에서 돌아가는 모든 프로세스는 모든 규약과 가정이 똑같음).
- 상식적으로 프로세스는 실행시키면 한 줄 씩 순차적으로 실행이 됨. 그리고, OS위에 프로세스가 여러 개가 있으면, OS는 이 프로세스들을 돌아가면서 실행시키게 됨. 프로그램 짠 사람 입장에서는 내꺼만 실행되겠지 하고 코드를 짜지만, OS는 사실 여러개 를 돌아가면서 실행을 시키고 있는 것(어쨋든 동시에 실행 시킴). 프로세스 하나는 기본적으로 하나의 순서만 실행시킬 수 있음. 하지만 하나의 프로세스 안에서 하나의 흐름이 아니라, 다른 실행 순서로 진행되는 것을 만들고 싶은 경우가 있음. 그러면 프로세스 하나가 중간에 process를 새로 만들 수 있음. 그렇게 되면 새로운 프로그램이 실행된것 처럼 OS위에서 돌게 되는 것. 운영체제 입장에서는 서로 다른 프로그램이나 마찬가지. B 프로세스는 사실 A프로세스에서 만든 것이지만, 서로의 존재도 모르고 정보나 결과등을 주고 받을 수도 없음. 메모리 공유가 불가능함(사실 부모프로세스는 자식프로세스가 뭐가 있는지 알 수 있고, 통신도 가능함. 다만 메모리 공유가 안되서 데이터 주고받는 방식이 복잡한 것).
- 근데 여기서 프로세스 추상화할때, “메모리/CPU 너 혼자 거의 다 쓴다고 쳐라” 라고 이렇게 추상화되있는 상태인데, 그 상황에서 1번 프로세스가 2번 프로세스 실행을 시켰는데, 1번에 있는 메모리와 2번에 있는 메모리가 공유가 안됨. 1번 프로세스는 2번 프로세스의 존재도 몰라. 그래서 메모리가 공유가 안되니깐, 다른 방법을 써야 함. 파일로 저장해서 가져오든지, 네트워크 통신을 쓰던지 해야함.
- 쓰레드도 거의 똑같지만, 프로세스를 만들고 사용하는데 새로운거 파는 것도 시간도 들고 정보 주고받는것도 귀찮고 그래. 그럴 때 쓰는게 쓰레드. 한 프로세스 안에서 쓰레드를 팔 수도 있어. 그러면 쓰레드들은 OS입장에서 완전 별개의 프로세스까지는 아니지만, 스케쥴링(프로세스 여러개가 돌아가면서 실행되는 것)에서는 프로세스 처럼 취급함. 스케쥴링 차원에서는 프로세스 대접해주고, 스케쥴링 아닐때는 그냥 프로세스에 준하는 정도. A 프로세스에서 쓰레드 3개를 파면 3개 다 A프로세스에 접근할 수 있음. 스케쥴링만 따로 되고, 서로 접근은 가능한 상태.
- 동시작업 해야 할 때, 프로세스 여러개 만들 수도 있고, 쓰레드를 만들어서 할 수도 있음. 서로 장단점이 있으니깐 존재 하겠지. CPU하나에서는 사실 다 싱글스레드로 하나 뭐 프로세스를 파나 어쩌나 다 비슷비슷함. 동시 실행되는 느낌만 주고, 어차피 CPU 코어 하나만 붙잡고 조지고 있는 상태. 요즘은 코어가 하나짜리인게 없고 보통 한 8개씩 있음. 나는 멀티프로세싱이나 멀티쓰레딩으로 코드만 짜 놓으면 OS가 알아서 분배함.

- 코드 짤때 조심해야 되는것은 쓰레딩에서 쓰레드 3개 만들었으면, 걔네가 결과를 서로 서로 가져와야 함. 그 결과를 가져오는 방법이 **join**. 1 2 3 쓰레드가 열심히 돌다가 끝나는데서 끝나는 로직을 짜야 함. 그 끝난걸 언제 합칠지를 알려주는게 join. 쓰레드마다 따로 조인을 정할수가 있고, 세개 다 끝나면 다같이 join하자고 할 수도 있음. 파이썬에서는 api가 다 있어서 리턴으로 알아서 가져옴. **Multiprocessing.Map** 함수가 모든 과정을 간단하게 만들어줌. 우리가 아는 map이랑 똑같아서 멀티프로세싱을 쉽게 만들어줌. 멀티쓰레딩에도 위 같은 map같은게 있음. 하지만 파이썬의 멀티쓰레딩은 사실은 멀티쓰레딩이 아니고, 실제로 하나가 cpu를 잡고 있으면 다른것들은 실행이 안됨. 하지만, 멀티쓰레딩도 cpu가 아닌걸 동시에 여러개 해야 할때는 의미가 있어. 크롤링하면 콜 쓰고 돌아오는게 너무 오래걸려서, 네트워크 쏘고 돌아오는 시긴이 같은게 오래걸리거든. 쏘라는 명령어는 순서대로 실행되긴 하는데, 그래도 의미가 있을 때가 많음. 혹은 file IO에서 명령 해놓고 기다리거나 그런데서는 멀티쓰레딩을 하는게 의미가 있음. 파이썬이 알아서 멀티쓰레딩도 돌아가면서 명령어를 쏘고 기다렸다가 하고 그렇게 함.
- 동시에 실행되는 쓰레드가 있으면 동시에 데이터를 읽거나 쓸때 문제가 생길 수 있음. 그래서 파이썬은 멀티쓰레딩을 막아 놓은 것. 예를들면 내가 x=2를 읽는중인데 읽는 딱 그시점에 다른쓰레드에서 x=3을 할당해버리면, 갑자기 문제가 생기거든. 파이썬은 애초부터 그런 것을 고려 안하고 만들다가, 나중에는 그냥 모양만 멀티쓰레딩 하려고 하다 보니깐 짜기가 어려워서 하나의 쓰레드가 CPU먹을 때는 다른 쓰레드는 다 못돌게 막아버림(100코어 CPU여도 똑같음).
- 파이썬은 멀티프로세싱은 돼. 다만, 멀티프로세싱은 메모리 카피 가안되서 불편할 때가 있어. 하지만, 파이썬에서는 멀티쓰레딩이 안되니깐, 특별한 상황 아니면 멀티프로세싱을 쓰는 경우가 많지.

- `파이썬 이외에 다른 곳에서는 서로 메모리 공유 되는게 당연히 좋은거 아닌가?`
- `A: 자신있게 다 짤 수 있으면, 멀티쓰레딩으로 해도 되는데 프로그램이 커지다 보면 메모리 구분이 생각보다 엄청 어려움. 거기서 프로세스 새로 파면, 메인프로세스에 있는 메모리를 1도 신경 안쓰고 짤 수가 있어서 하는 것. 간단한 로직이나 그런건 쓰레도로 짜면 좋고 속도도 빠름. 하지만, 완전히 새로운 큰 기능이 돌게 할 때는 원래꺼랑 어디서 충돌날지 모르니깐 그냥 프로세스를 새로 팜. 즉, 어차피 CPU에 뭘 어떻게 할당할지는 OS에서 결정하는거라서 뭘 해도 상관없고, 심지어 쓰레드가 더 switching cost도 적은데, 계속 충돌되거나 복잡해지는 문제 때문에 프로세스를 쓰는 것.`

``

Non-block과 Block의 개념.
